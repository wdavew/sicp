#+TITLE: 2.3.3 Representing Sets

* Representing Sets
Choosing a good representation for sets (unordered collecmplement ~union-set~, ~intersection-set~, ~element-of-set?~, and
~adjoin-set~.

** Unordered Lists
*** ~element-of-set~:
#+BEGIN_SRC scheme :session :exports both
(define (element-of-set? x set)
  (cond ((null? set) #false)
        ((= x (car set)) #true)
        (else (element-of-set? x (cdr set)))))

(element-of-set? 3 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: #t

*** ~adjoin-set~:
#+BEGIN_SRC scheme :session :exports both
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(adjoin-set 6 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
| 6 | 1 | 2 | 3 | 4 | 5 |

*** ~intersection-set~:
#+BEGIN_SRC scheme :session :exports both
(define (intersection-set a b)
  (cond ((or (null? a) (null? b)) '())
        ((element-of-set? (car a) b)
         (cons (car a) (intersection-set (cdr a) b)))
        (else (intersection-set (cdr a) b))))
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |


Theese implementations aren't very efficient. ~element-of-set~ does a full scan
of the list to search for a given element, so its time complexity is O(n),
making the complexity of intersection and union-set O(n^2).

*** Ex. 2.59
**** ~union-set~
#+BEGIN_SRC scheme :session :exports both
(define (union-set a b)
  (cond ((null? a) b)
        ((element-of-set? (car a) b)
         (union-set (cdr a) b))
        (else (cons (car a) (union-set (cdr a) b)))))
#+END_SRC

#+RESULTS:
| 4 | 1 | 3 |

*** Ex. 2.60
Now we redefine the representations allowing for duplicate elements:
#+BEGIN_SRC scheme :session :exports both
(define (element-of-set? a set)
  (cond ((null? set) #false)
        ((equal? a (car set)) #true)
        (else (element-of-set? a (cdr set)))))

(define (adjoin-set a set)
  (cons a set))

(define (intersection-set a b)
  (cond ((or (null? a) (null? b)) '())
        ((element-of-set? (car a) b)
         (adjoin-set (car a) (intersection-set (cdr a) b)))
        (else (intersection-set (cdr a) b))))

(define (union-set a b)
  (if (null? a)
      b
      (union-set (cdr a) (adjoin-set (car a) b))))

(union-set '(1 2 3) '(1 2 3 3 4))
#+END_SRC

#+RESULTS:
| 3 | 2 | 1 | 1 | 2 | 3 | 3 | 4 |

If we don't care about duplicates, the ~union-set~ procedure can now run in O(n)
time (because we don't have to check if the element already exists first).
